<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目录 x86中断&#x2F;异常处理(tss和tf作用) 重要函数说明 创建进程(线程) 调度，运行 do_wait &amp; do_exit do_execve 其它系统调用   FAQ 一个进程被创建后如何开始执行？  一个用户进程如果因为时间片用完而被调度掉后，再次被调度回来时会从哪里继续执行？  一个进程的完整生命周期？  fork调用，为什么父进程返回值为pid，子进程返回值为0（涉及到用户进程">
<meta property="og:type" content="article">
<meta property="og:title" content="ucore lab3 总结">
<meta property="og:url" content="http://yoursite.com/2020/09/20/ucore-lab3-%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="rain的随笔">
<meta property="og:description" content="目录 x86中断&#x2F;异常处理(tss和tf作用) 重要函数说明 创建进程(线程) 调度，运行 do_wait &amp; do_exit do_execve 其它系统调用   FAQ 一个进程被创建后如何开始执行？  一个用户进程如果因为时间片用完而被调度掉后，再次被调度回来时会从哪里继续执行？  一个进程的完整生命周期？  fork调用，为什么父进程返回值为pid，子进程返回值为0（涉及到用户进程">
<meta property="og:locale" content="zh">
<meta property="og:image" content="http://yoursite.com/images/2020-09-20-ucore-lab3-%E6%80%BB%E7%BB%93/image-20200920200402375.png">
<meta property="og:image" content="http://yoursite.com/images/2020-09-20-ucore-lab3-%E6%80%BB%E7%BB%93/image-20200925120822768.png">
<meta property="article:published_time" content="2020-09-20T15:52:30.000Z">
<meta property="article:modified_time" content="2021-04-01T16:08:26.677Z">
<meta property="article:author" content="rain">
<meta property="article:tag" content="数学 计算机 御坂美琴">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/2020-09-20-ucore-lab3-%E6%80%BB%E7%BB%93/image-20200920200402375.png">

<link rel="canonical" href="http://yoursite.com/2020/09/20/ucore-lab3-%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh'
  };
</script>

  <title>ucore lab3 总结 | rain的随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">rain的随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">A secret base!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">42</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/20/ucore-lab3-%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/images_lx/avatar_idenn.png">
      <meta itemprop="name" content="rain">
      <meta itemprop="description" content="记录一些关于数学、计算机的知识，以及一些日常。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="rain的随笔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ucore lab3 总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-20 23:52:30" itemprop="dateCreated datePublished" datetime="2020-09-20T23:52:30+08:00">2020-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-02 00:08:26" itemprop="dateModified" datetime="2021-04-02T00:08:26+08:00">2021-04-02</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/09/20/ucore-lab3-%E6%80%BB%E7%BB%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/20/ucore-lab3-%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li>x86中断/异常处理(tss和tf作用)</li>
<li>重要函数说明<ol>
<li>创建进程(线程)</li>
<li>调度，运行</li>
<li>do_wait &amp; do_exit</li>
<li>do_execve</li>
<li>其它系统调用</li>
</ol>
</li>
<li>FAQ<ol>
<li>一个进程被创建后如何开始执行？ </li>
<li>一个用户进程如果因为时间片用完而被调度掉后，再次被调度回来时会从哪里继续执行？ </li>
<li>一个进程的完整生命周期？ </li>
<li>fork调用，为什么父进程返回值为pid，子进程返回值为0（<strong>涉及到用户进程的创建</strong>）</li>
</ol>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实验3涉及到的知识点：</p>
<ol>
<li>x86中断中tss的作用（类似的内核栈，中断帧的概念）</li>
<li>进程如何创建、执行、切换（do_fork, do_wait, do_exit等系统调用的设计与实现）</li>
<li>用户进程的创建、执行过程</li>
<li>用户ulib库fork, wait, exit的实现</li>
</ol>
<a id="more"></a>

<h3 id="x86中断-异常处理-tss和tf作用"><a href="#x86中断-异常处理-tss和tf作用" class="headerlink" title="x86中断/异常处理(tss和tf作用)"></a>x86中断/异常处理(tss和tf作用)</h3><p><em>p.s. 见x86 manual Vol. 1 6-11</em></p>
<p>If the code segment for the handler procedure has the same privilege level as the currently executing program or task, the handler procedure uses the current stack; if the handler executes at a more privileged level, the processor switches to the stack for the handler’s privilege level.</p>
<p><strong>Call</strong></p>
<p>If no stack switch occurs, the processor does the following when calling an interrupt or exception handler (see Figure 6-5):</p>
<ol>
<li>Pushes the current contents of the <strong>EFLAGS</strong>, CS, and <strong>EIP</strong> registers (in that order) on the stack.</li>
<li>Pushes an <strong>error code</strong> (if appropriate) on the stack.</li>
<li>Loads the segment selector for the new code segment and the new instruction pointer (from the interrupt gate or trap gate) into the CS and EIP registers, respectively.</li>
<li>If the call is through an interrupt gate, clears the <strong>IF flag</strong> in the EFLAGS register.</li>
<li>Begins execution of the handler procedure.</li>
</ol>
<p>If a stack switch does occur, the processor does the following:</p>
<ol>
<li>Temporarily saves (internally) the current contents of the SS, ESP, EFLAGS, CS, and EIP registers.</li>
<li>Loads the segment selector and stack pointer for the new stack (that is, the stack for the privilege level being called) <strong>from the TSS into the SS and ESP registers</strong> and switches to the new stack.</li>
<li>Pushes the temporarily saved SS, ESP, EFLAGS, CS, and EIP values for the interrupted procedure’s stack onto the new stack.</li>
<li>Pushes an error code on the new stack (if appropriate).</li>
<li>Loads the segment selector for the new code segment and the new instruction pointer (from the interrupt gate or trap gate) into the CS and EIP registers, respectively.</li>
<li>If the call is through an interrupt gate, clears the IF flag in the EFLAGS register.</li>
<li>Begins execution of the handler procedure at the new privilege level.</li>
</ol>
<p><strong>return</strong></p>
<p>A return from an interrupt or exception handler is initiated with the IRET instruction. The IRET instruction is similar to the far RET instruction, except that it also restores the contents of the EFLAGS register for the interrupted proce-dure. </p>
<p>When executing a return from an interrupt or exception handler from the same privilege level as the inter-rupted procedure, the processor performs these actions:</p>
<ol>
<li>Restores the CS and EIP registers to their values prior to the interrupt or exception.</li>
<li>Restores the EFLAGS register.</li>
<li>Increments the stack pointer appropriately.</li>
<li>Resumes execution of the interrupted procedure.</li>
</ol>
<p>When executing a return from an interrupt or exception handler from a different privilege level than the interrupted procedure, the processor performs these actions:</p>
<ol>
<li>Performs a privilege check.</li>
<li>Restores the CS and EIP registers to their values prior to the interrupt or exception.</li>
<li>Restores the EFLAGS register.</li>
<li>Restores the SS and ESP registers to their values prior to the interrupt or exception, resulting in a stack switch back to the stack of the interrupted procedure.</li>
<li>Resumes execution of the interrupted procedure.</li>
</ol>
<p><img src="/images/2020-09-20-ucore-lab3-%E6%80%BB%E7%BB%93/image-20200920200402375.png" alt="image-20200920200402375"></p>
<p>总结：</p>
<p>发生中断，无特权级转换时，使用原本的栈来存储中断帧。发生特权级转换时（好像只有用户态到内核态），使用当前进程tss中的ss0, esp0所指向的栈（内核栈）来存储中断帧，且cpu会在中断帧中额外存储当前的ss和esp。（<em>p.s. cpu通过比较中断向量指向的中断描述符和cs寄存器来检测是否存在特权级的转换。而执行iret时，cpu通过比较栈中的cs和cs寄存器来检测是否需要特权级的转换</em>）</p>
<h3 id="重要函数说明"><a href="#重要函数说明" class="headerlink" title="重要函数说明"></a>重要函数说明</h3><h4 id="创建进程-线程"><a href="#创建进程-线程" class="headerlink" title="创建进程(线程)"></a>创建进程(线程)</h4><ol>
<li><p>kernel_thread</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags)</span></span></span><br></pre></td></tr></table></figure>

<p>作用：创建一个内核线程，该线程将执行fn函数，参数为arg，clone_flags控制是否共享父进程内存，返回线程pid。</p>
<p>实现：</p>
<ol>
<li><p>设置tf</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br></pre></td></tr></table></figure>
<p>其中kernel_thread_entry如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread_entry:        # void kernel_thread(void)</span><br><span class="line"></span><br><span class="line">    pushl %edx              # push arg</span><br><span class="line">    call *%ebx              # call fn</span><br><span class="line"></span><br><span class="line">    pushl %eax              # save the return value of fn(arg)</span><br><span class="line">    call do_exit            # call do_exit to terminate current thread</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><p>中断帧中的eip被设置为了kernel_thread_entry，<strong>如果让cpu根据该中断帧返回，cpu便会回到kernel_thread_entry</strong>，然后由于通用寄存器ebx, edx也已经恢复成fn, arg的值，因而可以成功调用fn函数。</p>
</li>
<li><p>后面do_fork中的copy_thread函数会将进程context中的eip设为forkret，而forkret便会让进程从中断帧返回</p>
</li>
<li><p>当进程结束时会调用do_exit</p>
</li>
</ol>
</li>
<li><p>调用do_fork</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>do_fork</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent's user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process's proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span><br></pre></td></tr></table></figure>

<p>作用：从父进程产生一个子进程（通过clone_flags来控制是否共享内存）</p>
<p>说明：目前只用于实现kernel_thread函数，如果要让用户进程通过do_fork来产生子进程，应该需要再封装一个类似于kernel_thread的函数，其中tf.eip的设置就不会用kernel_thread_entry了。</p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//    1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">   <span class="comment">//    2. call setup_kstack to allocate a kernel stack for child process (8KB)</span></span><br><span class="line">   <span class="comment">//    3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">   <span class="comment">//    4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">   <span class="comment">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">   <span class="comment">//    6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line"><span class="comment">//    7. set ret vaule using child proc's pid</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>alloc_proc, 分配一个pcb结构体</p>
</li>
<li><p>setup_kstack, 分配内核栈空间(8KB)</p>
</li>
<li><p>copy_mm, 复制页表/共享页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_mm(<span class="keyword">uint32_t</span> clone_flags, struct proc_struct *proc)</span><br></pre></td></tr></table></figure>

<p><code>clone_flags &amp; CLONE_VM</code>为真时，proc的mm设置为current-&gt;mm，即和当前进程共享内存。</p>
<p><em>p.s. vma一致，因此进程有效的虚拟内存空间一致。页表一致，因此访问同一份物理地址</em></p>
<p>否则，复制当前进程的虚拟内存(vma)，复制物理内存并设置对应的页表。（复制了当前进程的内存）</p>
<p>实现：</p>
<p>copy_mm</p>
<p>-&gt; dup_mmap, 调用copy_range复制每一个vma</p>
<p>-&gt; copy_range, 复制一段虚拟地址对应的物理内存，并设置页表</p>
</li>
<li><p>copy_thread, 设置tf, context</p>
<p>中断帧位于内核栈顶部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>设置线程context的初始状态，eip设置为forkret</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;</span><br><span class="line">proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf); #更新栈顶位置</span><br></pre></td></tr></table></figure>
</li>
<li><p>get_pid, 设置进程pid</p>
<p>hash_proc, 将进程添加到哈希表hash_list</p>
<p>set_links, 将进程添加到进程双向链表proc_list，并将进程设置为其父进程最小的子进程cptr</p>
</li>
<li><p>wakeup_proc, 将进程设置为runnable</p>
</li>
</ol>
</li>
</ol>
<h4 id="调度，运行"><a href="#调度，运行" class="headerlink" title="调度，运行"></a>调度，运行</h4><ol>
<li><p>schedule</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>作用：</p>
<p>按照FIFO的策略，从进程链表中选择一个进程执行。如果没有找到的话，执行idle进程。</p>
</li>
<li><p>proc_run</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_run(struct proc_struct *proc)</span><br></pre></td></tr></table></figure>

<p> 作用：</p>
<p> 开始运行一个进程</p>
<p> 实现:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">current = proc; <span class="comment">//设置proc为当前进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//kstack+KSTACKSIZE为进程内核栈栈顶，设置ts中的esp0，当中断且存在特权级转换时，使用进程的内核栈。</span></span><br><span class="line">load_esp0(next-&gt;kstack + KSTACKSIZE); </span><br><span class="line"></span><br><span class="line"><span class="comment">//切换页目录表。因为内核代码位于0-4M以内，而所有进程的页表都存在该段地址的映射，因此切换后，后面的代码都是能正常执行的</span></span><br><span class="line">lcr3(next-&gt;cr3);</span><br><span class="line"></span><br><span class="line">switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch_to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">switch_to:                      # switch_to(from, to)</span><br><span class="line"></span><br><span class="line">    # save from&#39;s registers</span><br><span class="line">    movl 4(%esp), %eax          # eax points to from</span><br><span class="line">    popl 0(%eax)                # save eip !popl</span><br><span class="line">    movl %esp, 4(%eax)</span><br><span class="line">    movl %ebx, 8(%eax)</span><br><span class="line">    movl %ecx, 12(%eax)</span><br><span class="line">    movl %edx, 16(%eax)</span><br><span class="line">    movl %esi, 20(%eax)</span><br><span class="line">    movl %edi, 24(%eax)</span><br><span class="line">    movl %ebp, 28(%eax)</span><br><span class="line"></span><br><span class="line">    # restore to&#39;s registers</span><br><span class="line">    movl 4(%esp), %eax          # not 8(%esp): popped return address already</span><br><span class="line">                                # eax now points to to</span><br><span class="line">    movl 28(%eax), %ebp</span><br><span class="line">    movl 24(%eax), %edi</span><br><span class="line">    movl 20(%eax), %esi</span><br><span class="line">    movl 16(%eax), %edx</span><br><span class="line">    movl 12(%eax), %ecx</span><br><span class="line">    movl 8(%eax), %ebx</span><br><span class="line">    movl 4(%eax), %esp</span><br><span class="line"></span><br><span class="line">    pushl 0(%eax)               # push eip</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<p>保存当前上下文到切换前进程(from)的context中，并恢复切换后进程(to)的context</p>
</li>
</ol>
<h4 id="do-wait-amp-do-exit"><a href="#do-wait-amp-do-exit" class="headerlink" title="do_wait &amp; do_exit"></a>do_wait &amp; do_exit</h4><ol>
<li><p>do_exit</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do_exit - called by sys_exit</span></span><br><span class="line"><span class="comment">//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process</span></span><br><span class="line"><span class="comment">//   2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.</span></span><br><span class="line"><span class="comment">//   3. call scheduler to switch to other process</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span></span></span><br></pre></td></tr></table></figure>

<p>作用：</p>
<p>释放进程内存空间，将进程设置为ZOMBIE状态，并唤醒父线程（设置为RUNNABLE），然后调用调度器。</p>
<p>关键代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lcr3(boot_cr3);</span><br><span class="line"><span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">    exit_mmap(mm);	<span class="comment">//是copy_mm的逆过程，释放了物理内存和页表</span></span><br><span class="line">    put_pgdir(mm);	<span class="comment">//释放页目录表</span></span><br><span class="line">    mm_destroy(mm);	<span class="comment">//释放vma</span></span><br><span class="line">&#125;</span><br><span class="line">current-&gt;mm = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>如果该进程有子进程，则还需要将子进程设置为init进程的子进程。</p>
</li>
</ol>
<ol start="2">
<li><p>do_wait</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack</span></span><br><span class="line"><span class="comment">//         - proc struct of this child.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> only after do_wait function, all resources of the child proces are free.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_wait(<span class="keyword">int</span> pid, <span class="keyword">int</span> *code_store)</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<p>等待一个或任意一个子进程执行do_exit变为Zombie状态，然后释放子进程的结构体</p>
</li>
</ol>
<h4 id="do-execve"><a href="#do-execve" class="headerlink" title="do_execve"></a>do_execve</h4><ol>
<li><p>do_execve</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do_execve - call exit_mmap(mm)&amp;put_pgdir(mm) to reclaim memory space of current process</span></span><br><span class="line"><span class="comment">//           - call load_icode to setup new memory space accroding binary prog.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_execve(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<p>根据二进制程序，为当前进程设置新的内存空间</p>
<p>注意点：</p>
<ol>
<li>在lab3中，user_main进程是通过kernel_thread创建的，所以刚开始是一个内核进程。但通过sys_execve系统调用后，新的内存空间</li>
</ol>
</li>
<li><p>load_icode</p>
<p>作用：</p>
<p>将ELF文件读到内存，并为当前进程重新设置内存空间(mm虚拟内存，页表)。</p>
<p><strong>并修改了当前进程的tf为：cs为用户段，esp使用用户栈，eip为elf-&gt;entry</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tf-&gt;tf_cs = USER_CS;</span><br><span class="line">tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">tf-&gt;tf_eflags = FL_IF;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="其它系统调用"><a href="#其它系统调用" class="headerlink" title="其它系统调用"></a>其它系统调用</h4><ol>
<li><p>do_yeild</p>
<p>进行一次进程调度（通过设置need_reschedule）</p>
</li>
<li><p>do_kill</p>
<p>将进程Flag设置为PF_EXITING，当switch_to到该进程后会触发do_exit(KILLED)</p>
</li>
</ol>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ol>
<li><p>一个进程被创建后如何开始执行？</p>
<p>答：</p>
<ol>
<li>通过kernel_thread创建的内核进程。kernel_thread调用do_fork（分配内核栈，内存空间）后，进程状态为Runnable，当被调度器调度到时(schedule)，会通过proc_run -&gt; switch_to进行上下文切换，而由于进程的初始上下文(context)的eip被设置为了forkret，于是会从forkret开始执行，forkret会执行中断返回的代码，iret到kernel_thread_entry处开始执行，从而执行进程的函数代码。</li>
<li>用户进程参考FAQ#4</li>
<li>进程调用do_execve后会重新分配内存空间，重新设置tf(eip为elf-&gt;entry)，重新开始执行。</li>
</ol>
</li>
<li><p>一个用户进程如果因为时间片用完而被调度掉后，再次被调度回来时会从哪里继续执行？</p>
<p>当CPU遇到中断后，会进入异常处理程序，（vector.S -&gt; __all_traps -&gt; trap() -&gt; trap_dispatch() -&gt; 异常处理 -&gt; 返回到trap_ret -&gt; 中断返回），ucore对于时钟中断的处理是将当前的进程设置为need_resched，从而在trap()中会调用schedule()。</p>
<p>中断时，进程的“用户态上下文”被存入中断帧中（该进程的内核栈栈顶；其中一部分由硬件完成如cs, eip, eflag，其它如通用寄存器则由软件完成）。而之后在内核态进行的一系列函数调用也是使用该进程的内核栈。在执行schedule后，通过软件将该进程的“内核态上下文”存入该进程数据结构的context变量中（eip为switch_to()调用的下一条指令）。因此再次切换回来时，仍处于内核态，并从switch_to()下一条继续执行，经过一系列函数返回，最终回到trap_ret，从进程的中断帧返回到用户态，也就是该进程时钟中断之前的状态。</p>
</li>
<li><p>一个进程的完整生命周期？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process's state in his life cycle</span></span><br><span class="line"><span class="keyword">enum</span> proc_state &#123;</span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// uninitialized</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// sleeping</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// runnable(maybe running)</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// almost dead, and wait parent proc to reclaim his resource</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/2020-09-20-ucore-lab3-%E6%80%BB%E7%BB%93/image-20200925120822768.png" alt="image-20200925120822768"></p>
</li>
<li><p>fork调用，为什么父进程返回值为pid，子进程返回值为0（<strong>涉及到用户进程的创建</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cprintf(&quot;I am the parent. Forking the child...\n&quot;);</span><br><span class="line">if ((pid &#x3D; fork()) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	cprintf(&quot;I am the child.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<p>父进程执行路线：</p>
<ol>
<li><p>fork() -&gt; /user/libs/syscall::sys_fork() </p>
<p>int SYS_fork引起中断，<strong>保存中断帧</strong>（父进程的内核栈中）</p>
</li>
<li><p>__all_traps -&gt; trap -&gt; trap_dispatch -&gt; syscall -&gt; <strong>do_fork</strong></p>
<p>​    do fork<strong>参数为父进程的中断帧</strong> </p>
</li>
<li><p>从do_fork返回到syscall</p>
<p>syscall中代码：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf-&gt;tf_regs.reg_eax &#x3D; syscalls[num](arg);</span><br></pre></td></tr></table></figure>

<p> 将父进程的中断帧的eax修改为do_fork返回的pid</p>
</li>
<li><p>返回到__all_traps -&gt; trapret</p>
<p>从中断帧返回，继续执行fork()后代码</p>
</li>
</ol>
<p>子进程执行路线：</p>
<ol>
<li><p>schedule -&gt; proc_run - &gt; switch_to -&gt; fork_ret</p>
<p>从中断帧返回，执行fork()后的代码</p>
</li>
</ol>
<p>可以看到，父进程更改了eax，故返回值变为pid，子进程则为原始的eax（这里我还不太清楚为什么一定为0）</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/14/ucore-lab2%E6%80%BB%E7%BB%93/" rel="prev" title="ucore lab2总结">
      <i class="fa fa-chevron-left"></i> ucore lab2总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/11/%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E6%90%AD%E5%BB%BAoverleaf/" rel="next" title="在虚拟机上搭建overleaf">
      在虚拟机上搭建overleaf <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86中断-异常处理-tss和tf作用"><span class="nav-number">3.</span> <span class="nav-text">x86中断&#x2F;异常处理(tss和tf作用)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重要函数说明"><span class="nav-number">4.</span> <span class="nav-text">重要函数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAQ"><span class="nav-number">5.</span> <span class="nav-text">FAQ</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rain"
      src="/images/images_lx/avatar_idenn.png">
  <p class="site-author-name" itemprop="name">rain</p>
  <div class="site-description" itemprop="description">记录一些关于数学、计算机的知识，以及一些日常。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TheRainstorm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheRainstorm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1544016010@qq.com" title="E-Mail → mailto:1544016010@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rain</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'o4cQoSCyl8A6rNyF3TQecBOG-gzGzoHsz',
      appKey     : 'RN9rQAQldGQFicEMmzpFUcMA',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
